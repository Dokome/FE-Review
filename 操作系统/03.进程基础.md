## 进程基础
> 主要为进程的介绍

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个 **运行中** 的程序，就被称为 **进程（Process）**。

#### 并发与并行

并发是在一个处理器核心中通过 **中断** 的方式快速切换，给使用者多个程序同时进行的感觉，而并行通过利用现代 CPU 多核的特点同时执行多个进程。

<img src="https://blog-assets-1301745442.cos.ap-nanjing.myqcloud.com/assets/image-20220513215425253.png" style="width:600px;float:left;">

#### 进程的状态

在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。

<img src="https://blog-assets-1301745442.cos.ap-nanjing.myqcloud.com/assets/image-20220513220307556.png" style="width:600px;float:left;">

| 状态     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 运行状态 | 该时刻进程占用 CPU                                           |
| 就绪状态 | 可运行，由于其他进程处于运行状态而暂时停止运行               |
| 阻塞状态 | 该进程正在等待某一事件发生（如 I/O 操作）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行。 |
| 创建状态 | 进程正在被创建时的状态；                                     |
| 结束状态 | 进程正在从系统中消失时的状态；                               |

<img src="https://blog-assets-1301745442.cos.ap-nanjing.myqcloud.com/assets/image-20220513220633195.png" style="width:600px;float:left;">

- **NULL -> 创建状态：**一个新进程被创建时的第一个状态；
- **创建状态 -> 就绪状态：**当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- **就绪态 -> 运行状态：**处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- **运行状态 -> 结束状态：**当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- **运行状态 -> 就绪状态：**处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- **运行状态 -> 阻塞状态：**当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- **阻塞状态 -> 就绪状态：**当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

**其他**

如果此时在就绪或者阻塞状态时，程序是没有运行的，系统会将其放入硬盘，称为 **挂起状态**。加上挂起状态后，流程图如下所示。

<img src="https://blog-assets-1301745442.cos.ap-nanjing.myqcloud.com/assets/image-20220513221116545.png" style="width:600px;float:left;">

#### 进程的控制结构

> 在操作系统中，是用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。

**PCB** **是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

- 进程的描述信息
  - 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
  - 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；
- 进程控制和管理信息：
  - 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
  - 进程优先级：进程抢占 CPU 时的优先级；
- 资源的分配清单
  - 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
- CPU 相关信息
  - CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

**组织方式**

- 通常是通过 **链表** 的方式进行组织，把具有 **相同状态的进程链在一起，组成各种队列**。
  - 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
  - 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
  - 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。
- 索引方式，将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。

#### 进程的控制

- 创建进程
  - 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB，PCB 是有限的，若申请失败则创建失败；
  - 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；
  - 初始化 PCB；
  - 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；
- 终止进程
  - 查找需要终止的进程的 PCB；
  - 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；
  - 如果其还有子进程，则应将其所有子进程终止；
  - 将该进程所拥有的全部资源都归还给父进程或操作系统；
  - 将其从 PCB 所在队列中删除；
- 阻塞进程
  - 找到将要被阻塞进程标识号对应的 PCB；
  - 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；
  - 将该 PCB 插入到阻塞队列中去；
- 唤醒进程
  - 在该事件的阻塞队列中找到相应进程的 PCB；
  - 将其从阻塞队列中移出，并置其状态为就绪状态；
  - 把该 PCB 插入到就绪队列中，等待调度程序调度；

#### 进程的切换

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个**一个进程切换到另一个进程运行，称为进程的上下文切换**。

- 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

**切换场景**

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；